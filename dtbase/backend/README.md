# DTBase Backend

The backend is the heart of DTBase. The frontend is just a pretty wrapper for the backend, and all the services are just scripts that call various backend API endpoints. All data is stored in the PostgreSQL database, and the backend is the only recommended way to access that database.

The backend is a web app implemented using FastAPI. It takes in REST requests and returns responses.

## Code structure
* `run.sh`. This is script you call to run the FastAPI app.
* `run_localdb.sh`. Just like `run.sh` except sources a different file of secrets and ensures that a local PostgreSQL server is running.
* `create_app.py`. A tiny script that calls `main.create_app()`.
* `main.py`. The module that defines how the FastAPI app is set up, its settings, endpoints, etc.
* `routers`. The API divides into subsections, such as `/user` for user management and `/sensor` for sensor data. Each of these is implemented in a separate file in `routers`.
* `models.py`. Whenever two files in `routers` use the same Pydantic model for some endpoint, that is kept in `models.py`.
* `database`. Everything related to direct access to the PostgreSQL database.
    * `structure.py`. Defines what are all the tables and their columns and constraints.
    * `locations.py/models.py/services.py` etc. Provide add/edit/delete functions for all the things stored in the database, such as locations, sensors, sensor data, models, model data, and users.
    * `queries.py`. More complex SQL queries and queries used by several files.
    * `db_docker.py`. Utilities for starting a PostgreSQL server and checking if one is running. Used mostly by tests, but also bu `run_localdb.sh`.
    * `utils.py`. Miscellaneous utilities for things like creating new database sessions. Most importantly has too module-level constants, `DB_ENGINE` and `DB_SESSION_MAKER`, that are the one-stop-shop of all other modules whenever a connection to the database is needed.
* `exc.py`. Custom exception classes used by various modules.
* `auth.py`. Everything related to authenticating users. Authentication uses JSON Web Tokens (JWT). See below for how this affects using the API.
* `config.py`. Various modes in which the database can be run, e.g. for development or debugging purposes.

## API documentation

Documentation listing all the API endpoints and their payloads, return values, etc., is automatically generated by FastAPI. If you are developing/running locally, and your backend is running at `http://localhost:5000`, you can find these docs at `http://localhost:5000/docs`. Correspondingly for an Azure deployment it will be something like `https://<your-azure-app-name>_backend.azurewebsites.net/docs`.

### Authentication

To be able to access any of the API end points you need an authentication token. You can get one from the `/auth/login` endpoint using a username and a password. Once you've obtained a token, you need to add it to header of any other API calls you make as a bearer token. So if `/auth/login` returned
```
{
    "access_token": "abc"
    "refresh_token": "xyz"
}
```
then you would call the other end points with the following in the header of the request:
```
Authorization: Bearer abc
```

If your token expires, you can use the refresh token to get a new for some time still, by calling the `/auth/refresh` end point. This one requires setting you header like above, but using the refresh token (`xyz`) rather than the access token (`abc`).

### Locations

Locations can be defined using any combination of floating point, integer, or string variables.   These variables, known as _LocationIdentifiers_ must be inserted into the database before an actual _Location_ can be entered.  The set of _LocationIdentifiers_ that is sufficient to define a _Location_ is called a _LocationSchema_.   A _Location_ will therefore have a _LocationSchema_, and one _LocationXYZValue_ for each _LocationIdentifier_ within that schema (where _XYZ_ can be "Float", "Integer" or "String").

### Sensors

The Sensor data model is as follows.   Every _Sensor_ has a _SensorType_ which in turn specifies the variable(s) it can measure - these are known as _SensorMeasures_.  Each _SensorMeasure_ specifies its datatype (float, int, string, or bool), and these are used to define the type of the corresponding _SensorXYZReadings_.   A _Sensor_ may also have a _SensorLocation_, which specifies a _Location_ as defined above, and a time window (possibly open-ended) when the sensor was at that location.

### Models

TODO: Write a summary of how storing model data works.

### Users

TODO: Write a summary of how user management works.

## The Default User

When starting a new deployment of a DTBase-based digital twin one encounters a chicken-and-egg dilemma: To be able to create users, or do anything really, with the backend, one needs to first have a registered user (the `/user/create-user` endpoint requires a valid JWT token like every other endpoint). To way out of this is the default user. If one sets the environment variable `DT_DEFAULT_USER_PASS` and starts the backend, at startup time a user with the "email" `default_user@localhost` is created, with the given password. One can use this to log in and create some proper users. One should then unset the `DT_DEFAULT_USER_PASS` environment variable and restart the backend. This causes the default user to be deleted.

Often it's handy to keep the default user around for development purposes, but one should be careful not to leave it on a live deployment with sensitive data stored.
